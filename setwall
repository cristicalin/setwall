#!/usr/bin/python

import sys
import atexit
import argparse
import logging

import dbus
import dbus.service
import dbus.glib

from urllib2 import quote, unquote
from apscheduler.scheduler import Scheduler

from gi.repository import Gtk as gtk
from gi.repository import GObject as gobject
from gi.repository import AppIndicator3 as appindicator

# Local imports
from globals import *
from settings import *
from filelist import *
from wallpapermanager import *

# Global variables, dirty hack
sched = None
my_settings = None
play_icon = None
stop_icon = None
file_list = None
toggle_menu = None
wpm = None

# make apscheduler happy
logging.basicConfig(format=LOG_FORMAT)

# allow other threads to execute
dbus.glib.init_threads()
gobject.threads_init()

# This is a handler class for the DBus messages, it allows
# the application to receive next and previous messages
class handledbus(dbus.service.Object):

  @dbus.service.method("%s.%s" % (BASE_ID, APP_NAME),
                       in_signature='', out_signature='')
  def next(self):
    next_wallpaper()

  @dbus.service.method("%s.%s" % (BASE_ID, APP_NAME),
                       in_signature='', out_signature='')
  def previous(self):
    previous_wallpaper()

  @dbus.service.method("%s.%s" % (BASE_ID, APP_NAME),
                       in_signature='', out_signature='')
  def toggle(self):
    toggle_schedule()
    
  @dbus.service.method("%s.%s" % (BASE_ID, APP_NAME),
                       in_signature='', out_signature='')
  def randomize(self):
    global file_list
    reorder_func(file_list.randomize)
    
  @dbus.service.method("%s.%s" % (BASE_ID, APP_NAME),
                       in_signature='', out_signature='')
  def sort(self):
    global file_list
    reorder_func(file_list.sort)
    
  @dbus.service.method("%s.%s" % (BASE_ID, APP_NAME),
                       in_signature='', out_signature='')
  def quit(self):
    quit_app()

# Global functions start here
def quit_app(item = None):
  # we neet to stop both the notifier as well as the gtk main loop
  global file_list
  file_list.close()
  gtk.main_quit()

def next_wallpaper(item = None):
  global file_list
  global wpm
  wpm.set_wallpaper(file_list.get_next_file())
  reset_schedule()

def previous_wallpaper(item = None):
  global file_list
  global wpm
  wpm.set_wallpaper(file_list.get_previous_file())
  reset_schedule()

def toggle_schedule(item = None, toggle = True):
  global toggle_menu
  if item is None:
    item = toggle_menu
  global my_settings
  if toggle:
    my_settings.set_wallpaper_schedule(not my_settings.get_wallpaper_schedule())
  if my_settings.get_wallpaper_schedule():
    if toggle:
      sched.add_interval_job(next_wallpaper,
                             seconds=my_settings.get_wallpaper_interval())
    item.set_image(stop_icon)
    item.set_label(TEXT_PAUSE)
  else:
    if toggle:
      sched.unschedule_func(next_wallpaper)
    item.set_image(play_icon)
    item.set_label(TEXT_CONTINUE)

def reorder_func(func):
  func()
  set_index(file_list)
  save_json()

def show_settings(item = None):
  my_settings.show_window()

def file_change_callback(action, filename):
  global wpm
  if action == "add":
    wpm.show_notification("Wallpaper Added",
                         "New file: %s" % wpm.shorten(filename.split("/")[-1], 32),
			 "file://%s" % quote(filename))
  elif action == "remove":
    wpm.show_notification("Wallpaper Removed",
                         "Removed file: %s" % wpm.shorten(filename.split("/")[-1], 32),
			 None)

# Build the application menu which is delivered
# via the appindicator functionality
def get_app_menu():
  global my_settings
  load_icons()
  menu = gtk.Menu()
   
  next_menu = gtk.MenuItem()
  next_menu.set_label("Next")
  next_menu.connect("activate", next_wallpaper)
  menu.append(next_menu)

  prev_menu = gtk.MenuItem()
  prev_menu.set_label("Previous")
  prev_menu.connect("activate", previous_wallpaper)
  menu.append(prev_menu)

  options_menu_item = gtk.MenuItem()
  options_menu_item.set_label("Options");
  menu.append(options_menu_item)
  options_menu = gtk.Menu()

  options_range = my_settings.get_wallpaper_options_range()
  options_group = []
  for option in options_range[1]:
    menu_option = gtk.RadioMenuItem.new_with_label(options_group,
                                                   option.title())
    menu_option.connect("activate", 
                        lambda item, data: my_settings.set_wallpaper_options(data),
			option)
    options_group = menu_option.get_group()
    if option == my_settings.get_wallpaper_options():
      menu_option.set_active(True)
    options_menu.append(menu_option)
  options_menu_item.set_submenu(options_menu)

  global toggle_menu
  toggle_menu = gtk.ImageMenuItem(" ")
  toggle_menu.connect("activate", toggle_schedule)
  toggle_menu.set_always_show_image(True)
  menu.append(toggle_menu)

  menu.append(gtk.SeparatorMenuItem())

  settings_menu = gtk.MenuItem("Settings")
  settings_menu.connect("activate", show_settings)
  menu.append(settings_menu)

  quit_menu = gtk.MenuItem("Quit")
  quit_menu.connect("activate", quit_app)
  menu.append(quit_menu)

  menu.show_all()
  return menu

# Keep icons stored in memory so we don't have to
# reload them each time the menu is toggled
def load_icons():
  global play_icon
  play_icon = gtk.Image()
  play_icon.set_from_icon_name(gtk.STOCK_MEDIA_PLAY, gtk.IconSize.MENU)
  play_icon.show()
  global stop_icon 
  stop_icon = gtk.Image()
  stop_icon.set_from_icon_name(gtk.STOCK_MEDIA_STOP, gtk.IconSize.MENU)
  stop_icon.show()

# Reset the schedule
def reset_schedule():
  global my_settings
  global sched
  for job in sched.get_jobs():
    sched.unschedule_job(job)
  if my_settings.get_wallpaper_schedule():
    sched.add_interval_job(next_wallpaper,
                           seconds=my_settings.get_wallpaper_interval())

# Load and process settings, will be also called
# when apply is pressed in the settings dialog
def load_settings():
  global file_list
  global my_settings
  file_list.load(my_settings.get_wallpaper_path(),
                 my_settings.get_saved_list())
  save_json()
  reset_schedule()
  toggle_schedule(toggle=False)

# Set the file list index to the current wallpaper
# this gets called multiple times so it became a function
def set_index(list):
  global wpm
  list.set_index(wpm.get_wallpaper())

# Save the current file_list json format to the settings
def save_json():
  global my_settings
  global file_list
  my_settings.set_saved_list(file_list.get_json())

# Main application body
if __name__ == "__main__":
  # initialize DBus, we need to kill the previous instance as a first thing
  session_bus = dbus.SessionBus()

  try:
    running_obj = session_bus.get_object("%s.%s" % (BASE_ID, APP_NAME),
                                         "%s/%s" % (APP_PATH, APP_NAME))
    running_obj.quit()
  except dbus.DBusException as e:
    None

  # Parse the command line arguments
  parser = argparse.ArgumentParser("Wallpaper Changer")
  parser.add_argument("-p", "--path", type=str,
                      help="Path in which wallpapers reside")
  parser.add_argument("-i", "--interval", type=int,
                      help="Time interval in seconds between switches")
  parser.add_argument("-s", "--schedule", type=bool,
                      help="Scheduled wallpaper changes")
  args = parser.parse_args()
  my_settings = settings(args = args, save_callback = load_settings)
   
  app = appindicator.Indicator.new(
    APP_NAME.replace("_","-"), APP_ICON,
    appindicator.IndicatorCategory.APPLICATION_STATUS
  )
  app.set_status(appindicator.IndicatorStatus.ACTIVE)
  app.set_menu(get_app_menu())
  
  # Schedule periodic changes of the firewall
  # we only start a job here if the we need to, user might want
  # to start with this setting disabled
  sched = Scheduler()

  # build the file list and create the wallpaper change object
  file_list = filelist(file_change_callback)
  load_settings()
  wpm = wallpapermanager(my_settings)
  set_index(file_list)

  # make sure we properly clean up after ourselves 
  atexit.register(lambda: sched.shutdown(wait=True))

  session_name = dbus.service.BusName("%s.%s" % (BASE_ID, APP_NAME),
                                      session_bus)
  session_object = handledbus(session_bus,
                              "%s/%s" % (APP_PATH, APP_NAME))

  sched.start()
  
  gtk.main()

  sys.exit(0)
