#!/usr/bin/python

import sys
import os
import random
import time
import atexit
import argparse
import pyinotify

import dbus
import dbus.service
import dbus.glib

from urllib2 import quote, unquote
from apscheduler.scheduler import Scheduler
from gi.repository import Gio as gio
from gi.repository import Gtk as gtk
from gi.repository import GObject as gobject
from gi.repository import AppIndicator3 as appindicator
from gi.repository import Notify as notify

# Local imports
from globals import *
from settings import *

# Global variables, dirty hack
sched = None
interval = 0
app_settings = None
my_settings = None
play_icon = None
stop_icon = None
file_list = None
pyin_notifier = None

# allow other threads to execute
dbus.glib.init_threads()
gobject.threads_init()

# Hack to implement pointer-like behavior in python
# This is needed synce pygtk cannot update the data on a GtkMenuItem
# so the menu item is passed as a reference and the contents in the
# reference is updated when the menu value is toggled
class ref:
  
  def __init__(self, obj):
    self.obj = obj

  def get(self):
    return self.obj

  def set(self, obj):
    self.obj = obj

# This handles setting the wallpaper on the Gnome desktop
# and returning the name of the current wallpaper file
# This assumes that the current wallpaper is set
# if picture-uri in gsettings is null this will return None
class setwall:

  def __init__(self, settings):
    self.settings = settings
    self.notification = notify.Notification.new("", "", None)
 
  def get_wallpaper(self):
    try:
      old_wallpaper = self.settings.get_string(PICTURE_URI)
      tmp = old_wallpaper.split("/")
      return unquote(tmp[len(tmp)-1])
    except:
      return None

  def set_wallpaper(self, filename):
    old_wallpaper = self.get_wallpaper()
    new_file = filename.split("/")
    new_wallpaper = "file://%s" % quote(filename)
    self.settings.set_string(PICTURE_URI, new_wallpaper)
    self.notification.update(
      "Wallpaper changed",
      "<b>Old:</b> %s<br/><b>New:</b> %s" 
      % (old_wallpaper, new_file[len(new_file)-1]),
      None
    )
    self.notification.show()

# File list maintains a randomized list of files in a directory
# and behaves like a circular list so get_next and get_previous
# will never return an error.
# By design, this assumes there is at least one file in the
# directory it is monitoriing.
class filelist:

  def __init__(self, path):
    self.LOCAL_COUNT = 0
    self.DIR_PATH = path
    self.LOCAL_FILE_LIST = os.listdir(self.DIR_PATH)
    random.shuffle(self.LOCAL_FILE_LIST)

  def get_next_file(self):
    self.LOCAL_COUNT += 1
    if self.LOCAL_COUNT >= len(self.LOCAL_FILE_LIST):
      self.LOCAL_COUNT = 0
    tmp = "%s/%s" % (self.DIR_PATH, self.LOCAL_FILE_LIST[self.LOCAL_COUNT])
    return tmp

  def get_previous_file(self):
    self.LOCAL_COUNT -= 1
    if self.LOCAL_COUNT < 0:
      self.LOCAL_COUNT = len(self.LOCAL_FILE_LIST) - 1
    tmp = "%s/%s" % (self.DIR_PATH, self.LOCAL_FILE_LIST[self.LOCAL_COUNT])
    return tmp

  def set_index(self, file):
    while self.LOCAL_COUNT < len(self.LOCAL_FILE_LIST):
      if self.LOCAL_FILE_LIST[self.LOCAL_COUNT] == file:
        return
      self.LOCAL_COUNT += 1

  def add_file(self, file):
    self.LOCAL_FILE_LIST.insert(self.LOCAL_COUNT+1, file)

  def remove_file(self, file):
    self.LOCAL_FILE_LIST.remove(file)

# This is a handler used by PyINotify to watch contents of
# wallpapers directory path and notify file_list of changes
class handlereload(pyinotify.ProcessEvent):

  def process_IN_CREATE(self, event):
    global file_list
    if not event.dir:
      file_list.add_file(event.name)

  def process_IN_DELETE(self, event):
    global file_list
    if not event.dir:
      file_list.add_file(event.name)

# This is a handler class for the DBus messages, it allows
# the application to receive next and previous messages
class handledbus(dbus.service.Object):

  global file_list

  @dbus.service.method("%s.%s" % (BASE_ID, APP_NAME),
                       in_signature='', out_signature='')
  def next(self):
    wp.set_wallpaper(file_list.get_next_file())

  @dbus.service.method("%s.%s" % (BASE_ID, APP_NAME),
                       in_signature='', out_signature='')
  def previous(self):
    wp.set_wallpaper(file_list.get_previous_file())

  @dbus.service.method("%s.%s" % (BASE_ID, APP_NAME),
                       in_signature='', out_signature='')
  def quit(self):
    global pyin_notifier
    pyin_notifier.stop()
    gtk.main_quit()
    

# Global functions start here
def quit(item):
  # we neet to stop both the notifier as well as the gtk main loop
  global pyin_notifier
  pyin_notifier.stop()
  gtk.main_quit()

def next_wallpaper(item = None):
  global file_list
  wp.set_wallpaper(file_list.get_next_file())

def previous_wallpaper(item = None):
  global file_list
  wp.set_wallpaper(file_list.get_previous_file())

def toggle_schedule(item, schedule):
  if schedule.get():
    sched.unschedule_func(next_wallpaper)
    item.set_image(play_icon)
    item.set_label(TEXT_CONTINUE)
  else:
    sched.add_interval_job(next_wallpaper, seconds=interval)
    item.set_image(stop_icon)
    item.set_label(TEXT_PAUSE)
  schedule.set(not schedule.get())
  app_settings.set_boolean(WALLPAPER_SCHEDULE, schedule.get())

def show_settings(item = None):
  my_settings.show_window()

# Build the application menu which is delivered
# via the appindicator functionality
def get_app_menu(settings, schedule):
  load_icons()
  menu = gtk.Menu()
   
  next_menu = gtk.MenuItem()
  next_menu.set_label("Next Wallpaper")
  next_menu.connect("activate", next_wallpaper)
  menu.append(next_menu)

  prev_menu = gtk.MenuItem()
  prev_menu.set_label("Previous Wallpaper")
  prev_menu.connect("activate", previous_wallpaper)
  menu.append(prev_menu)

  options_menu_item = gtk.MenuItem()
  options_menu_item.set_label("Scaling Options");
  menu.append(options_menu_item)
  options_menu = gtk.Menu()

  options_range = settings.get_range(PICTURE_OPTIONS)
  for option in options_range[1]:
    menu_option = gtk.MenuItem(option.title())
    menu_option.connect("activate", 
      lambda item, data: settings.set_string(PICTURE_OPTIONS, data), option)
    options_menu.append(menu_option)
  options_menu_item.set_submenu(options_menu)

  toggle_text = TEXT_CONTINUE
  toggle_icon = play_icon
  if schedule.get():
    toggle_text = TEXT_PAUSE
    toggle_icon = stop_icon
  toggle_menu = gtk.ImageMenuItem()
  toggle_menu.connect("activate", toggle_schedule, schedule)
  toggle_menu.set_always_show_image(True)
  toggle_menu.set_image(toggle_icon)
  toggle_menu.set_label(toggle_text)
  menu.append(toggle_menu)

  menu.append(gtk.SeparatorMenuItem())

  settings_menu = gtk.MenuItem("Settings")
  settings_menu.connect("activate", show_settings)
  menu.append(settings_menu)

  quit_menu = gtk.MenuItem("Quit")
  quit_menu.connect("activate", quit)
  menu.append(quit_menu)

  menu.show_all()
  return menu

# Keep icons stored in memory so we don't have to
# reload them each time the menu is toggled
def load_icons():
  global play_icon
  play_icon = gtk.Image()
  play_icon.set_from_icon_name(gtk.STOCK_MEDIA_PLAY, gtk.IconSize.MENU)
  play_icon.show()
  global stop_icon 
  stop_icon = gtk.Image()
  stop_icon.set_from_icon_name(gtk.STOCK_MEDIA_STOP, gtk.IconSize.MENU)
  stop_icon.show()

# Main application body
if __name__ == "__main__":
  # Parse the command line arguments
  parser = argparse.ArgumentParser("Wallpaper Changer")
  parser.add_argument("-p", "--path", type=str,
                      help="Path in which wallpapers reside")
  parser.add_argument("-i", "--interval", type=int,
                      help="Time interval in seconds between switches")
  parser.add_argument("-s", "--schedule", type=bool,
                      help="Scheduled wallpaper changes")
  args = parser.parse_args()

  # Store command line arguments in the settings for future reference
  # This means that if we want to change something we only need
  # to pass the correct command line value to the application one time
  app_settings = gio.Settings.new("%s.%s" % (BASE_ID, APP_NAME.replace("_", "-")))
  if args.path != None:
    app_settings.set_string(WALLPAPER_PATH, args.path)
  if args.interval != None:
    app_settings.set_int(WALLPAPER_INTERVAL, args.interval)
  if args.schedule != None:
    app_settings.set_boolean(WALLPAPER_SCHEDULE, args.schedule)

  my_settings = settings()
   
  # Get the values from the settings
  # This ensures we have proper values even if no command lines
  # was passed to the application
  path = app_settings.get_string(WALLPAPER_PATH)
  interval = app_settings.get_int(WALLPAPER_INTERVAL)
  schedule = ref(app_settings.get_boolean(WALLPAPER_SCHEDULE))

  app = appindicator.Indicator.new(
    APP_NAME.replace("_","-"), "preferences-desktop-wallpaper",
    appindicator.IndicatorCategory.APPLICATION_STATUS
  )
  app.set_status(appindicator.IndicatorStatus.ACTIVE)
  notify.init(APP_NAME)

  # These are Gnome specific settings for wallpaper and we need
  # a separate object to interact with them
  wp_settings = gio.Settings.new(WALLPAPER_SETTING)
  app.set_menu(get_app_menu(wp_settings, schedule))

  # build the file list and create the wallpaper change object
  file_list = filelist(path)
  wp = setwall(wp_settings)
  file_list.set_index(wp.get_wallpaper())

  # Initialize the notifier and watch the wallpaper folder for any changes
  # we only register to the create and delete events
  # we don't care about other events since they do not impact
  # the list of files in the directory
  pyin_wm = pyinotify.WatchManager()
  pyin_mask = pyinotify.IN_DELETE | pyinotify.IN_CREATE
  pyin_handler = handlereload()
  pyin_notifier = pyinotify.ThreadedNotifier(pyin_wm, pyin_handler)
  pyin_wdd = pyin_wm.add_watch(path, pyin_mask, rec=False)
  pyin_notifier.start()

  # Schedule periodic changes of the firewall
  # we only start a job here if the we need to, user might want
  # to start with this setting disabled
  sched = Scheduler()
  sched.start()
  if schedule.get():
    sched.add_interval_job(next_wallpaper, seconds=interval)

  # make sure we properly clean up after ourselves 
  atexit.register(lambda: sched.shutdown(wait=True))

  # initialize DBus
  session_bus = dbus.SessionBus()
  session_name = dbus.service.BusName("%s.%s" % (BASE_ID, APP_NAME), session_bus)
  session_object = handledbus(session_bus, "%s/%s" % (APP_PATH, APP_NAME))

  gtk.main()

  sys.exit(0)
