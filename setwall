#!/usr/bin/python

from __future__ import division

import sys
import atexit
import argparse

import dbus
import dbus.service
import dbus.glib

from urllib2 import quote, unquote
from apscheduler.scheduler import Scheduler

from gi.repository import Gtk as gtk
from gi.repository import Gio as gio
from gi.repository import GdkPixbuf as pixbuf
from gi.repository import GObject as gobject
from gi.repository import AppIndicator3 as appindicator
from gi.repository import Notify as notify

# Local imports
from globals import *
from settings import *
from filelist import *

# Global variables, dirty hack
sched = None
my_settings = None
play_icon = None
stop_icon = None
file_list = None
toggle_menu = None
wp = None

# allow other threads to execute
dbus.glib.init_threads()
gobject.threads_init()

# This handles setting the wallpaper on the Gnome desktop
# and returning the name of the current wallpaper file
# This assumes that the current wallpaper is set
# if picture-uri in gsettings is null this will return None
class setwall:

  def __init__(self):
    self.notification = notify.Notification.new("", "", None)
 
  def get_wallpaper(self):
    try:
      global my_settings
      old_wallpaper = my_settings.get_wallpaper()
      tmp = old_wallpaper.split("/")
      return unquote(tmp[-1])
    except:
      return None

  def set_wallpaper(self, filename):
    global my_settings
    old_wallpaper = self.get_wallpaper()
    new_file = filename.split("/")
    new_wallpaper = "file://%s" % quote(filename)
    my_settings.set_wallpaper(new_wallpaper)
    self.show_notification("Wallpaper changed",
                           "<b>Old:</b> %s<br/><b>New:</b> %s" %
                           (shorten(old_wallpaper, 32),
			    shorten(new_file[-1], 32)),
			   new_wallpaper)

  def show_notification(self, title, message, filename):
    if filename is not None:
      file = gio.File.new_for_uri(filename)
      icon = pixbuf.Pixbuf.new_from_stream(file.read(None), None)
      scale = icon.get_width() / icon.get_height()
      resized_icon = icon.scale_simple(64, 64/scale,
                                       pixbuf.InterpType.BILINEAR)
      self.notification.set_icon_from_pixbuf(resized_icon)
      self.notification.update(title, message, None)
    else:
      self.notification.update(title, message, globals.APP_ICON)
    self.notification.show()

# This is a handler class for the DBus messages, it allows
# the application to receive next and previous messages
class handledbus(dbus.service.Object):

  @dbus.service.method("%s.%s" % (BASE_ID, APP_NAME),
                       in_signature='', out_signature='')
  def next(self):
    next_wallpaper()

  @dbus.service.method("%s.%s" % (BASE_ID, APP_NAME),
                       in_signature='', out_signature='')
  def previous(self):
    previous_wallpaper()

  @dbus.service.method("%s.%s" % (BASE_ID, APP_NAME),
                       in_signature='', out_signature='')
  def toggle(self):
    global toggle_menu
    toggle_schedule(toggle_menu)
    
  @dbus.service.method("%s.%s" % (BASE_ID, APP_NAME),
                       in_signature='', out_signature='')
  def quit(self):
    quit_app()

# Shorten long file names
def shorten(data, length):
  info = (data[:int(length/2)-1] + '..' + 
          data[-(int(length/2)-1):]) if len(data) > length else data
  return info

# Global functions start here
def quit_app(item = None):
  # we neet to stop both the notifier as well as the gtk main loop
  global file_list
  file_list.close()
  gtk.main_quit()

def next_wallpaper(item = None):
  global file_list
  global wp
  wp.set_wallpaper(file_list.get_next_file())

def previous_wallpaper(item = None):
  global file_list
  global wp
  wp.set_wallpaper(file_list.get_previous_file())

def toggle_schedule(item = None, toggle = True):
  global my_settings
  if toggle:
    my_settings.set_wallpaper_schedule(not my_settings.get_wallpaper_schedule())
  if my_settings.get_wallpaper_schedule():
    if toggle:
      sched.add_interval_job(next_wallpaper,
                             seconds=my_settings.get_wallpaper_interval())
    item.set_image(stop_icon)
    item.set_label(TEXT_PAUSE)
  else:
    if toggle:
      sched.unschedule_func(next_wallpaper)
    item.set_image(play_icon)
    item.set_label(TEXT_CONTINUE)

def show_settings(item = None):
  my_settings.show_window()

def file_change_callback(action, filename):
  global wp
  if action == "add":
    wp.show_notification("Wallpaper Added",
                         "New file: %s" % shorten(filename.split("/")[-1], 32),
			 "file://%s" % quote(filename))
  elif action == "remove":
    wp.show_notification("Wallpaper Removed",
                         "Removed file: %s" % filename.split("/")[-1],
			 None)

# Build the application menu which is delivered
# via the appindicator functionality
def get_app_menu():
  global my_settings
  load_icons()
  menu = gtk.Menu()
   
  next_menu = gtk.MenuItem()
  next_menu.set_label("Next")
  next_menu.connect("activate", next_wallpaper)
  menu.append(next_menu)

  prev_menu = gtk.MenuItem()
  prev_menu.set_label("Previous")
  prev_menu.connect("activate", previous_wallpaper)
  menu.append(prev_menu)

  options_menu_item = gtk.MenuItem()
  options_menu_item.set_label("Options");
  menu.append(options_menu_item)
  options_menu = gtk.Menu()

  options_range = my_settings.get_wallpaper_options_range()
  options_group = []
  for option in options_range[1]:
    menu_option = gtk.RadioMenuItem.new_with_label(options_group,
                                                   option.title())
    menu_option.connect("activate", 
                        lambda item, data: my_settings.set_wallpaper_options(data),
			option)
    options_group = menu_option.get_group()
    if option == my_settings.get_wallpaper_options():
      menu_option.set_active(True)
    options_menu.append(menu_option)
  options_menu_item.set_submenu(options_menu)

  global toggle_menu
  toggle_menu = gtk.ImageMenuItem(" ")
  toggle_menu.connect("activate", toggle_schedule)
  toggle_menu.set_always_show_image(True)
  menu.append(toggle_menu)

  menu.append(gtk.SeparatorMenuItem())

  settings_menu = gtk.MenuItem("Settings")
  settings_menu.connect("activate", show_settings)
  menu.append(settings_menu)

  quit_menu = gtk.MenuItem("Quit")
  quit_menu.connect("activate", quit_app)
  menu.append(quit_menu)

  menu.show_all()
  return menu

# Keep icons stored in memory so we don't have to
# reload them each time the menu is toggled
def load_icons():
  global play_icon
  play_icon = gtk.Image()
  play_icon.set_from_icon_name(gtk.STOCK_MEDIA_PLAY, gtk.IconSize.MENU)
  play_icon.show()
  global stop_icon 
  stop_icon = gtk.Image()
  stop_icon.set_from_icon_name(gtk.STOCK_MEDIA_STOP, gtk.IconSize.MENU)
  stop_icon.show()

# Load and process settings, will be also called
# when apply is pressed in the settings dialog
def load_settings():
  global file_list
  global my_settings
  global sched
  global toggle_menu
  file_list.load(my_settings.get_wallpaper_path())
  for job in sched.get_jobs():
    sched.unschedule_job(job)
  if my_settings.get_wallpaper_schedule():
    sched.add_interval_job(next_wallpaper,
                           seconds=my_settings.get_wallpaper_interval())
  toggle_schedule(toggle_menu, False)

# Main application body
if __name__ == "__main__":
  # Parse the command line arguments
  parser = argparse.ArgumentParser("Wallpaper Changer")
  parser.add_argument("-p", "--path", type=str,
                      help="Path in which wallpapers reside")
  parser.add_argument("-i", "--interval", type=int,
                      help="Time interval in seconds between switches")
  parser.add_argument("-s", "--schedule", type=bool,
                      help="Scheduled wallpaper changes")
  args = parser.parse_args()
  my_settings = settings(args = args, save_callback = load_settings)
   
  app = appindicator.Indicator.new(
    APP_NAME.replace("_","-"), globals.APP_ICON,
    appindicator.IndicatorCategory.APPLICATION_STATUS
  )
  app.set_status(appindicator.IndicatorStatus.ACTIVE)
  app.set_menu(get_app_menu())
  
  # Schedule periodic changes of the firewall
  # we only start a job here if the we need to, user might want
  # to start with this setting disabled
  sched = Scheduler()
  notify.init(APP_NAME)

  # build the file list and create the wallpaper change object
  file_list = filelist(file_change_callback)
  load_settings()
  wp = setwall()
  file_list.set_index(wp.get_wallpaper())

  # make sure we properly clean up after ourselves 
  atexit.register(lambda: sched.shutdown(wait=True))

  # initialize DBus
  session_bus = dbus.SessionBus()

  try:
    running_obj = session_bus.get_object("%s.%s" % (BASE_ID, APP_NAME),
                                         "%s/%s" % (APP_PATH, APP_NAME))
    running_obj.quit()
  except dbus.DBusException as e:
    None

  session_name = dbus.service.BusName("%s.%s" % (BASE_ID, APP_NAME),
                                      session_bus)
  session_object = handledbus(session_bus,
                              "%s/%s" % (APP_PATH, APP_NAME))

  sched.start()
  
  gtk.main()

  sys.exit(0)
